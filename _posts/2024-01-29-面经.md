---
layout:     post     # 使用的布局（不需要改）
title:      面经 # 标题 
subtitle:   Java面经，记录常见知识点和面试题 #副标题
date:       2024-01-29 # 时间
author:     Tong # 作者
header-img: img/post-bg-2015.jpg #这篇文章标题背景图片
catalog: true # 是否归档
tags: #标签
    - 面经

typora-root-url: ../../blog
typora-copy-images-to: ../assets/images
---

# 基础知识

### 1. 什么是反向代理？正向代理？

其实只需要简单的两句话就可以解释清楚，**客户端指的是用户，服务端指的是项目部署的服务**

- 正向代理：**客户端不想让服务器知道客户端的ip**，所以让代理服务器去访问，再返回给客户端。
- 反向代理：**服务器不想客户端知道是哪个服务器响应的**，所以让代理服务器去分配，让空闲的服务器去响应。



### 2、未完待续。。。



























# Java源码

### 1、你了解过延迟队列DelayQueue的底层实现原理吗？

`DelayQueue`是一种本地延迟队列，比如希望我们的任务在5秒后执行，就可以使用`DelayQueue`实现。常见的使用场景有：

- 订单10分钟内未支付，就取消。
- 缓存过期后，就删除。
- 消息的延迟发送等。

DelayQueue类属性：

````java
public class DelayQueue<E extends Delayed>
        extends AbstractQueue<E>
        implements BlockingQueue<E> {

    /**
     * 排它锁，用于保证线程安全
     */
    private final transient ReentrantLock lock = new ReentrantLock();

    /**
     * 底层是基于PriorityQueue实现
     */
    private final PriorityQueue<E> q = new PriorityQueue<E>();

    /**
     * 当前线程
     */
    private Thread leader = null;

    /**
     * 条件队列
     */
    private final Condition available = lock.newCondition();

}
````



<img src="/assets/images/image-20240223113300395.png" alt="image-20240223113300395" style="zoom:100%;float:left;" />



`DelayQueue`实现了`BlockingQueue`接口，提供了四组放数据和读数据的方法，来满足不同的场景。

`DelayQueue`底层采用组合的方式，复用`PriorityQueue`的按照延迟时间排序任务的功能，实现了延迟队列。

`DelayQueue`是线程安全的，内部使用`ReentrantLock`加锁。





### 2、什么是双亲委派机制？

> 当一个类加载器收到了类加载的请求的时候，它不会直接去加载指定的类，而是把这个请求委托给自己的父加载器去加载。**只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载**。

**双亲委派的核心思想：自下向上检查类是否已经被加载；从上至下尝试加载类**

![image-20240401093156133](/assets/images/image-20240401093156133.png)

Java中提供了四种类加载器，四种类加载器存在层级关系，bootstrap--> extension--> Application --> User，双亲委派机制实际上就是一种**选择机制**，也就是说类加载的时候需要用哪个类加载器加载。双亲委派机制的逻辑是，当一个类加载器收到加载请求时，不会直接加载，而是把这个**请求委托给自己的父加载器（上一级）来处理**，如果父加载器都不处理，那就由自己去处理，如果自己也处理不了，那就抛出异常`ClassNotFoundException`。



#### 为什么需要双亲委派机制？

使用双亲委派机制能够避免两个问题：

- 问题一：避免**同一个类在不同层级的类加载器中重复加载**，如果父类加载器已经加载过一次，子类加载器就不用加载了；
- 问题二：**保障核心类的安全**，有效**防止Java的核心API类在运行时被篡改**，从而保证所有子类共享同一基础类，减少性能开销和安全隐患问题。例如：输过来一个java.lang.String类，需要被加载时会传到bootstrap类加载器，发现已经被加载，就不会再加载，避免了核心类被篡改的风险。



#### 如何破坏双亲委派机制？

- **自定义类加载器**：在Java中，可以通过继承ClassLoader并重写其loadClass方法来创建自定义类加载器。通过这种方式，可以打破双亲委派机制，实现类的隔离。例如，在Tomcat中，每个Web应用都有自己的类加载器，从而实现了应用之间的类隔离。当两个Web应用中有相同限定名的类时，如Servlet类，Tomcat通过自定义类加载器保证它们是不同的类。

- **线程上下文类加载器**：在Java中，每个线程都有一个关联的上下文类加载器。通过设置线程的上下文类加载器，可以实现类的加载。例如，JDBC和JNDI等就是利用线程上下文类加载器来加载类的。

- **Osgi框架的类加载器**：Osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载。在Osgi中，每个Bundle都有自己的类加载器，当需要加载类时，会先在自己的存储空间中查找，如果找不到，则委托给父级Bundle的类加载器进行查找。这种机制打破了传统的双亲委派模型。

双亲委派机制等了解完再补充内容

















# Spring面经

### 1、BeanFactory 和 FactoryBean 有何区别？

#### 什么是BeanFactory?

BeanFactory的字面意思就是Bean工厂，转换一下思路，也就是Bean容器了。

<img src="/assets/images/image-20240219091948155.png" alt="image-20240219091948155" style="zoom:100%; float: left;" />

可以看到BeanFactory是一个接口，它在Spring中是最基础的接口之一了，作用就是定义获取和管理bean及bean的各种属性，在源代码中也可以看出来，里面有我们在编码过程中常用到的getBean()方法。



#### 什么是FactoryBean？

FactoryBean字面意思就是工厂Bean，它的职责是Spring提供给用户的一种实例化bean的方式，当然，是要通过实现该接口才可以。

<img src="/assets/images/image-20240219103006080.png" alt="image-20240219103006080" style="zoom:100%; float: left;" />

##### 使用例子：

###### 定义一个算法服务接口

```java
public interface AlgorithmService {
  
    public void encrypt();

}
```

###### MD5算法实现

```Java
public class MD5algorithmServiceImpl implements AlgorithmService {
    @Override
    public void encrypt() {
        System.out.println("MD5algorithmServiceImpl.encrypt");
    }
}
```

###### AES算法实现

```java
public class AESalgorithmServiceImpl implements AlgorithmService {

    @Override
    public void encrypt() {
        System.out.println("AESalgorithmServiceImpl.encrypt");
    }
}
```

###### 算法FactoryBean实现

````java
public class AlgorithmFactoryBean implements FactoryBean<AlgorithmService>{
    //算法类型：MD5 | AES
    private String algorithmType;
  
    @Override
    public AlgorithmService getObject() throws Exception {
        if("MD5".equals(algorithmType)){
            return new  MD5algorithmServiceImpl();
        }
        if("AES".equals(algorithmType)){
            return new AESalgorithmServiceImpl();
        }
        return null;
    }
  
    @Override
    public Class<?> getObjectType() {
        return AlgorithmService.class;
    }
  
    public String getAlgorithmType() {
        return algorithmType;
    }
  
    public void setAlgorithmType(String algorithmType) {
        this.algorithmType = algorithmType;
    }
}
````

###### AlgorithmFactoryBean配置类

```java
@Configuration
public class AlgorithmConfig {

    @Bean
    public AlgorithmFactoryBean algorithmFactoryBean(){
        AlgorithmFactoryBean algorithmFactoryBean = new AlgorithmFactoryBean();
        algorithmFactoryBean.setAlgorithmType("MD5");
        return algorithmFactoryBean;
    }

}
```

###### 注入使用

```java
@Autowired
private AlgorithmService algorithmService;

@RequestMapping("/test")
public  void test(){
    algorithmService.encrypt();
}
```



#### 小结

> BeanFactory 是 Spring 框架的核心接口之一，用于管理和获取应用程序中的 Bean 实例。它是一个工厂模式的实现，负责创建、配置和管理 Bean 对象。BeanFactory 是 Spring IoC 容器的基础，它可以从配置元数据（如 XML 文件）中读取 Bean 的定义，并在需要时实例化和提供这些 Bean。
>
> FactoryBean 是一个特殊的 Bean，它是一个工厂对象，用于创建和管理其他 Bean 的实例。FactoryBean 接口定义了一种创建 Bean 的方式，它允许开发人员在 Bean 的创建过程中进行更多的自定义操作。通过实现 FactoryBean 接口，开发人员可以创建复杂的 Bean 实例，或者在 Bean 实例化之前进行一些额外的逻辑处理。

区别在于，BeanFactory 是 Spring 框架的核心接口，用于管理和提供 Bean 实例，而 FactoryBean 是一个特殊的 Bean，用于创建和管理其他 Bean 的实例。FactoryBean 在 Bean 的创建过程中提供更多的自定义能力，允许进行额外的逻辑处理。





### 2、未完待续。。。

















































# MyBatis面经

### 1、MyBatis有哪些核心组件

#### BoundSql

`BoundSql`中就是对解析后的sql描述，包括对动态标签的解析，并且将 **#{}** 解析为占位符 **?** ，还包含参数的描述信息。这个类没有什么复杂操作，可以看作是解析后的sql描述对象。

`BoundSql`对象其实是从`MappedStatement`的成员变量`sqlSource`中获取的。 而`SqlSource`作为一个接口，它只有一个作用就是获取`BoundSql`对象。

````java
/**
 * An actual SQL String got from an {@link SqlSource} after having processed any dynamic content.
 * The SQL may have SQL placeholders "?" and an list (ordered) of an parameter mappings
 * with the additional information for each parameter (at least the property name of the input object to read
 * the value from).
 * <p>
 * Can also have additional parameters that are created by the dynamic language (for loops, bind...).
 *
 * 经过处理一些动态sql的部分获取到的真实sql，这个sql可能还有占位符?和一个参数映射的有序集合，并且还有每个参数的额外信息
 * @author Clinton Begin
 */
public class BoundSql {

  // 最终解析的sql，Mybatis将#{}和${}解析后的sql，其中#{}会被解析为?
  private final String sql;
  // 参数映射
  private final List<ParameterMapping> parameterMappings;
  // 参数对象
  private final Object parameterObject;
  // 额外的参数
  private final Map<String, Object> additionalParameters;
  // 元数据参数
  private final MetaObject metaParameters;

  public BoundSql(Configuration configuration, String sql, List<ParameterMapping> parameterMappings, Object parameterObject) {
    this.sql = sql;
    this.parameterMappings = parameterMappings;
    this.parameterObject = parameterObject;
    this.additionalParameters = new HashMap<>();
    this.metaParameters = configuration.newMetaObject(additionalParameters);
  }

  public String getSql() {
    return sql;
  }

  public List<ParameterMapping> getParameterMappings() {
    return parameterMappings;
  }

  public Object getParameterObject() {
    return parameterObject;
  }

  public boolean hasAdditionalParameter(String name) {
    String paramName = new PropertyTokenizer(name).getName();
    return additionalParameters.containsKey(paramName);
  }

  public void setAdditionalParameter(String name, Object value) {
    metaParameters.setValue(name, value);
  }

  public Object getAdditionalParameter(String name) {
    return metaParameters.getValue(name);
  }
}

````

















































# 数据库面经

### 1、什么情况下我们需要进行分库分表呢？

分库和分表的作用，待补充。。。

根据阿里巴巴的开发规范，单表超过500万条数据，或者超过2GB数据，就要考虑分表操作了。但是还是要根据我们的实际业务去考虑要不要分。









































# 未完待续。。。

